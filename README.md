# FIAP - Faculdade de Inform√°tica e Administra√ß√£o Paulista

<p align="center">
  <a href="https://www.fiap.com.br/">
    <img src="img/logo-fiap.png" alt="FIAP - Faculdade de Inform√°tica e Administra√ß√£o Paulista" border="0" width="40%" height="40%">
  </a>
</p>

---

# üì¶ Enterprise Challenge - Sprint 3


## üë• Grupo 26


## üë®‚Äçüéì Integrantes:
- Amanda Vieira Pires (RM5666330)
- Ana Gabriela Soares Santos (RM565235)
- Bianca Nascimento de Santa Cruz Oliveira (RM561390)
- Milena Pereira dos Santos Silva (RM565464)
- Nayana Mehta Miazaki (RM565045) 

## üë©‚Äçüè´ Professores:
### Tutor(a)  
-  Lucas Gomes Moreira
### Coordenador(a)  
- Andr√© Godoi

---

# üìú Descri√ß√£o do Projeto
## üöÄ Introdu√ß√£o

Dando continuidade ao projeto de manuten√ß√£o preditiva em linhas de envase, esta fase avan√ßa da simula√ß√£o de sensores para a estrutura√ß√£o e an√°lise de dados. Transformamos os dados coletados em um banco de dados relacional robusto e, a partir dele, desenvolvemos um modelo de Machine Learning para extrair insights valiosos. Esta etapa representa um ciclo completo de uma solu√ß√£o de digitaliza√ß√£o industrial, conectando a coleta de dados, o armazenamento estruturado e a aplica√ß√£o de intelig√™ncia preditiva.


Link do reposit√≥rio Sprint 1: https://github.com/fiap-ia-2025/enterprise-challenge-phase03

---

## üéØ Objetivo

- **Modelar um banco de dados relacional** funcional e normalizado para os dados dos sensores.
- **Criar um script SQL (`schema.sql`)** para definir a estrutura do banco.
- **Desenvolver um script Python (`import_data.py`)** para automatizar a cria√ß√£o e o povoamento do banco de dados a partir dos arquivos CSV.
- **Treinar um algoritmo de Machine Learning** para classificar o status operacional (`NORMAL`, `ALERTA_Pre_falha`, `FALHA_CRITICA`).
- **Gerar e justificar visualiza√ß√µes** que demonstrem a performance do modelo.
- **Documentar todo o processo** no GitHub, garantindo clareza e reprodutibilidade.

---

## üîß Pipeline de Solu√ß√£o e Execu√ß√£o

O projeto foi estruturado como um pipeline de dados semi-automatizado, garantindo um fluxo de trabalho eficiente desde a simula√ß√£o at√© a an√°lise preditiva.

- **Simula√ß√£o de Sensores (Wokwi + PlatformIO):** O projeto utiliza m√∫ltiplos ambientes no PlatformIO, um para cada sensor (DS18B20, MPU6050, HC-SR04). Ao selecionar e compilar um ambiente, um script de pr√©-compila√ß√£o (`update_diagram.py`) atualiza automaticamente o arquivo `diagram.json`, garantindo que o Wokwi sempre carregue o circuito correto para a simula√ß√£o.
- **Coleta de Dados (Manual):** Os dados gerados no monitor serial do Wokwi s√£o coletados e salvos nos respectivos arquivos `.csv` na pasta `data/`.
- **Estrutura√ß√£o de Dados (SQLite):** Um script Python (`import_data.py`) l√™ os arquivos `.csv`, cria um banco de dados SQLite com base em um esquema pr√©-definido (`schema.sql`) e popula as tabelas.
- **Machine Learning (Jupyter Notebook):** O notebook (`machine_learning.ipynb`) conecta-se ao banco de dados para treinar, testar e avaliar um modelo de classifica√ß√£o com `Scikit-learn`.

---

## üöÄ Como Executar o Projeto

### üìã Pr√©-requisitos

- Python 3.8+
- Visual Studio Code com as extens√µes:
  - PlatformIO IDE: Essencial para compilar e simular o c√≥digo do ESP32.
  - Wokwi for VS Code: Necess√°ria para rodar a simula√ß√£o dos circuitos.
  - Jupyter: Para executar os notebooks de an√°lise.
  - SQLite Viewer: (Opcional) Para inspecionar o banco de dados.



### Passo a Passo
O processo completo √© dividido em 3 fases principais: gerar os dados, estrutur√°-los no banco de dados e, finalmente, treinar o modelo de Machine Learning.

## üîπ Fase 1: Gera√ß√£o de Dados Simulados (Wokwi)

Existem duas maneiras de gerar os dados. Escolha a que melhor se adapta √† sua necessidade.

---

1. **Escolha o ambiente do sensor**  
   - Clique no √≠cone do PlatformIO (formiga) na barra lateral esquerda do VS Code.
   - Em PROJECT TASKS, expanda a lista e escolha o ambiente do sensor que deseja simular (ex: `sensor_nivel_hcsr04`).

2. **Compile o C√≥digo (Build):**  
   - Clique na op√ß√£o Build dentro do ambiente escolhido. 
   - Aguarde a mensagem de SUCCESS no terminal. Esse processo tamb√©m executa o script `update_diagram.py`, que atualiza o arquivo `diagram.json` com o circuito correto.

3. **Ajuste o `wokwi.toml`**  
   - Abra o arquivo `wokwi.toml` na raiz do projeto.
   - Altere a linha firmware para apontar para o arquivo `.elf` do sensor que voc√™ acabou de compilar. O caminho correto ser√° exibido no terminal ap√≥s o build.
     - Exemplo para o sensor de n√≠vel:
       
     ```toml
     firmware = ".pio/build/sensor_nivel_hcsr04/firmware.elf"
     ```

4. **Inicie a Simula√ß√£o**  
   - Pressione F1 para abrir a paleta de comandos do VS Code. 
   - Digite e selecione Wokwi: Start Simulator.
   - A simula√ß√£o iniciar√° em uma nova aba. Copie os dados gerados no Serial Monitor e salve-os no arquivo `.csv` correspondente dentro da pasta `data/`.

5. **Repita para os Outros Sensores**  
   - Para gerar os dados dos outros sensores, repita os passos de 1 a 4, selecionando o ambiente e atualizando o `wokwi.toml` para cada um.

---

## üîπ Fase 2: Estrutura√ß√£o dos Dados

  1. Instale as depend√™ncias Python:
  ```bash
    pip install pandas scikit-learn matplotlib seaborn
  ```

  2. Execute o script de importa√ß√£o para criar e popular o banco de dados `hermes_db.sqlite` e popul√°-lo com os dados dos arquivos CSV:
  ```bash
    python scripts/import_data.py
  ```

## üîπ Fase 3: An√°lise com Machine Learning

  1. (Opcional) An√°lise Explorat√≥ria:
       - Abra o notebook `notebooks/grafico.ipynb`.
       - Execute as c√©lulas para gerar gr√°ficos individuais para cada tipo de sensor, permitindo uma visualiza√ß√£o inicial dos dados coletados.
         
  2. Clique em "Executar Tudo" (Run All). O notebook ir√° treinar o modelo e exibir a Matriz de Confus√£o com os resultados.
       - Abra o notebook principal `notebooks/machine_learning.ipynb`.
       - Clique em **"Executar Tudo" (Run All)**. O notebook ir√° carregar os dados do banco, treinar o modelo de classifica√ß√£o e exibir a Matriz de Confus√£o com os resultados finais.



## üìå Justificativa da Escolha do Sensor

O sensor **DS18B20** foi escolhido para a leitura precisa de temperatura, o **MPU6050** para medir a vibra√ß√£o da m√°quina atrav√©s de seu aceler√¥metro, e o **HC-SR04** para a medi√ß√£o do n√≠vel de enchimento sem contato com o produto. Em conjunto, esses sensores permitem simular um cen√°rio realista de monitoramento em linhas de envase de bebidas, onde varia√ß√µes nessas tr√™s grandezas s√£o indicadores cr√≠ticos de poss√≠veis falhas no processo.

---

## üîå Esquema dos Circuitos

## üí® MPU6050
![Circuito MPU5060](img/mpu5060.JPG)

---

### üßæ Trecho Representativo do C√≥digo MPU6050

O trecho abaixo representa a l√≥gica principal do projeto, respons√°vel por:

- Simular a leitura de vibra√ß√£o com base na acelera√ß√£o detectada na m√°quina;
- Classificar o status do sistema em tr√™s n√≠veis: `NORMAL`, `ALERTA_Pre_falha` ou `FALHA_CRITICA`;
- Exibir os dados simulados no Monitor Serial em formato CSV (separado por v√≠rgulas), facilitando an√°lise posterior ou exporta√ß√£o.

```cpp
// Trecho representativo da leitura e visualiza√ß√£o dos dados do MPU6050

// Defini√ß√£o dos limites para classifica√ß√£o em NORMAL, ALERTA_Pre_falha ou FALHA_CRITICA
const double LIMITE_ALERTA = 16500.0; 
const double LIMITE_FALHA = 25000.0;

// Exibe os dados formatados no Monitor Serial
Serial.print(contador + 1);
Serial.print(",");
Serial.print(accTotal);
Serial.print(",");

// Classifica√ß√£o do status no Monitor Serial
if (accTotal < LIMITE_ALERTA) {
  Serial.println("NORMAL");
} else if (accTotal < LIMITE_FALHA) {
  Serial.println("ALERTA_Pre_falha");
} else {
  Serial.println("FALHA_CRITICA");
}

```
---

### ‚öôÔ∏è Funcionamento do Sistema MPU6050

1. O ESP32 simulado l√™ a acelera√ß√£o da m√°quina a cada 1 segundo atrav√©s do MPU6050.
2. A vibra√ß√£o √© simulada com valores variados, dependendo da movimenta√ß√£o dos eixos X, Y e Z.
3. Os dados s√£o classificados automaticamente em tr√™s status:
   - **NORMAL**: at√© 16500.0LSB/g
   - **ALERTA_Pre_falha**: de 16500.0LSB/g at√© 25000.0LSB/g
   - **FALHA_CRITICA**: acima de 25000.0LSB/g
4. Os dados s√£o exibidos no **Monitor Serial** no formato CSV:  
   `ID, Aceleracao_Total, Status`

---

### üîå Simula√ß√£o no Wokwi - MPU6050 e ESP32
![Simula√ß√£o MPU6050](img/mpu5060_terminal.JPG)

---

### üß™ Exemplo de Dados Coletados MPU6050

| ID | Aceleracao_Total| Status          |
|----------|----------------|------------------|
| 32   | 5049.47           | NORMAL           |
| 97    | 18426.64         | ALERTA_Pre_falha |
| 213    | 52453.14         | FALHA_CRITICA    |

---

### üìä Gr√°fico Gerado MPU6050

![Gr√°fico de Vibra√ß√£o](img/grafico_mpu5060.png)

### üìù Estrutura e Racional do Gr√°fico MPU6050

O gr√°fico gerado apresenta a varia√ß√£o da acelera√ß√£o simulada ao longo das medi√ß√µes, com o eixo X representando as medi√ß√µes (totalizando 500 medi√ß√µes) e o eixo Y representando a vibra√ß√£o em LSB/g (Least Significant Bit por g). Para facilitar a interpreta√ß√£o, a classifica√ß√£o foi colorida conforme **classifica√ß√£o autom√°tica do status operacional**:

- **NORMAL (verde)**: Acelera√ß√£o abaixo de 16500.0LSB/g - opera√ß√£o dentro do esperado.
- **ALERTA_Pre_falha (laranja)**: Acelera√ß√£o de 16500.0LSB/g at√© 25000.0LSB/g - poss√≠vel acerela√ß√£o demasiada, aten√ß√£o recomendada.
- **FALHA_CRITICA (vermelho)**: Acelera√ß√£o acima de 25000.0LSB/g - ‚Äì indicativo de falha cr√≠tica, requer a√ß√£o imediata.

---

## üå°Ô∏è DS18B20
![Circuito DS18B20](img/DS18B20.JPG)

### üßæ Trecho Representativo do C√≥digo DS18B20

O trecho abaixo representa a l√≥gica principal do projeto, respons√°vel por:

- Simular a leitura de temperatura de bebidas geladas com envase a frio;
- Classificar o status do sistema em tr√™s n√≠veis: `NORMAL`, `ALERTA_Pre_falha` ou `FALHA_CRITICA`;
- Exibir os dados simulados no Monitor Serial em formato CSV (separado por v√≠rgulas), facilitando an√°lise posterior ou exporta√ß√£o.

```cpp
// Trecho representativo da leitura e visualiza√ß√£o dos dados do DS18B20

// Defini√ß√£o dos limites para classifica√ß√£o em NORMAL, ALERTA_Pre_falha ou FALHA_CRITICA
const float TEMPERATURA_NORMAL_MIN = -1.0;
const float TEMPERATURA_NORMAL_MAX = 6.0;
const float TEMPERATURA_FALHA_CRITICA_MIN = -6.0;
const float TEMPERATURA_FALHA_CRITICA_MAX = 10.0;

// Exibe os dados formatados no Monitor Serial
Serial.print(contador + 1);
Serial.print(",");
Serial.print(temperatura);
Serial.print(",");

// Classifica√ß√£o do status no Monitor Serial
if (temperatura >= TEMPERATURA_NORMAL_MIN && temperatura <= TEMPERATURA_NORMAL_MAX) {
  Serial.println("NORMAL");
} else if (temperatura < TEMPERATURA_NORMAL_MIN || temperatura > TEMPERATURA_NORMAL_MAX) 
      
  if (temperatura >= TEMPERATURA_FALHA_CRITICA_MIN && temperatura <= TEMPERATURA_FALHA_CRITICA_MAX) {
      Serial.println("ALERTA_Pre_falha");
  } else {
      Serial.println("FALHA_CRITICA");
      }

```
---

### ‚öôÔ∏è Funcionamento do Sistema DS18B20

1. O ESP32 simulado l√™ a temperatura da m√°quina a cada 1 segundo atrav√©s do DS18B20.
2. A temperatura √© simulada com valores variados, conforme a oscila√ß√£o.
3. Os dados s√£o classificados automaticamente em tr√™s status:
   - **NORMAL**: at√© 6¬∫C
   - **ALERTA_Pre_falha**: de 6¬∫C at√© 10¬∫C
   - **FALHA_CRITICA**: acima de 10¬∫C
4. Os dados s√£o exibidos no **Monitor Serial** no formato CSV:  
   `ID, Temperatura, Status`

---

### üîå Simula√ß√£o no Wokwi - DS18B20 e ESP32
![Simula√ß√£o DS18B20](img/ds18b20_terminal.JPG)


### üß™ Exemplo de Dados Coletados DS18B20

| ID | Temperatura | Status          |
|----------|----------------|------------------|
| 17   | 1.37          | NORMAL           |
| 65   | 8.38         | ALERTA_Pre_falha |
| 118   | 14.25         | FALHA_CRITICA    |

### üìä Gr√°fico Gerado DS18B20

![Gr√°fico de Temperatura](img/grafico_DS18B20.png)

### üìù Estrutura e Racional do Gr√°fico DS18B20

O gr√°fico gerado apresenta a varia√ß√£o da temnperatura simulada ao longo das medi√ß√µes (totalizando 500 medi√ß√µes). Para facilitar a interpreta√ß√£o, a classifica√ß√£o foi colorida conforme **classifica√ß√£o autom√°tica do status operacional**:

- **NORMAL (verde)**: Temperatura abaixo de 6¬∫C - opera√ß√£o dentro do esperado.
- **ALERTA_Pre_falha (laranja)**: Temmperatura de 6¬∫C at√© 10¬∫C - poss√≠vel acerela√ß√£o demasiada, aten√ß√£o recomendada.
- **FALHA_CRITICA (vermelho)**: Temperatura acima de 10¬∫C - ‚Äì indicativo de falha cr√≠tica, requer a√ß√£o imediata.


## „Ä∞Ô∏è HC-SR04
![Circuito HC-SR04](img/HC-SR04.JPG)


### üßæ Trecho Representativo do C√≥digo HC-SR04

O trecho abaixo representa a l√≥gica principal do projeto, respons√°vel por:

- Simular a leitura de n√≠vel de enchimento dos recipientes de bebidas;
- Classificar o status do sistema em tr√™s n√≠veis: `NORMAL`, `ALERTA_Pre_falha` ou `FALHA_CRITICA`;
- Exibir os dados simulados no Monitor Serial em formato CSV (separado por v√≠rgulas), facilitando an√°lise posterior ou exporta√ß√£o.

```cpp
// Trecho representativo da leitura e visualiza√ß√£o dos dados do HC-SR04

// Defini√ß√£o dos limites para classifica√ß√£o em NORMAL, ALERTA_Pre_falha ou FALHA_CRITICA
const float ALTURA_MAXIMA = 20.0;
const float NIVEL_NORMAL_MIN = 19.0;
const float NIVEL_NORMAL_MAX = 20.0;
const float NIVEL_ALERTA_MIN = 16.0;
const float NIVEL_ALERTA_MAX = 19.0;

// Exibe os dados formatados no Monitor Serial
 Serial.print(contador + 1);
    Serial.print(",");
    Serial.print(distancia_cm);
    Serial.print(",");
    Serial.print(nivel_cm);
    Serial.print(",");

 // Classifica√ß√£o do status no Monitor Serial   
    if (nivel_cm >= NIVEL_NORMAL_MIN && nivel_cm <= NIVEL_NORMAL_MAX) {
      Serial.println("NORMAL");
    } else if (nivel_cm >= NIVEL_ALERTA_MIN && nivel_cm < NIVEL_NORMAL_MIN) {
      Serial.println("ALERTA_Pre_falha");
    } else {
      Serial.println("FALHA_CRITICA");
    }

```

---

### ‚öôÔ∏è Funcionamento do Sistema HC-SR04

1. O ESP32 simulado l√™ a dist√¢ncia do l√≠quido at√© o sensor HC-SR04 a cada 1 segundo.
2. A temperatura √© simulada com valores variados, conforme a oscila√ß√£o.
3. Os dados s√£o classificados automaticamente em tr√™s status:
   - **NORMAL**: acima de 20cm
   - **ALERTA_Pre_falha**: de 16 a 18cm
   - **FALHA_CRITICA**: abaixo de 16cm
4. Os dados s√£o exibidos no **Monitor Serial** no formato CSV:  
   `ID, Distancia_cm, Nivel_cm, Status`

---

### üîå Simula√ß√£o no Wokwi - HC-SR04 e ESP32
![Simula√ß√£o HC-SR04](img/HC-SR04_terminal.JPG)

### üß™ Exemplo de Dados Coletados HC-SR04

| ID | Distancia_cm | Nivel_cm         | Status          |
|----|--------------|------------------|-----------------|
| 29 | 1.94         | 23.06            | NORMAL          |
| 99 | 7.97         | 17.03            | ALERTA_Pre_falha|
| 213| 9.07         | 15.93            | FALHA_CRITICA   |

### üìä Gr√°fico Gerado HC-SR04

![Gr√°fico de N√≠vel de Enchimento](img/grafico_HC-SR04.png)

### üìù Estrutura e Racional do Gr√°fico HC-SR04

O gr√°fico gerado apresenta a varia√ß√£o do n√≠vel de enchimentos dos recipientes simulado ao longo das medi√ß√µes (totalizando 500 medi√ß√µes). Para facilitar a interpreta√ß√£o, a classifica√ß√£o foi colorida conforme **classifica√ß√£o autom√°tica do status operacional**:

- **NORMAL (verde)**: N√≠vel de 19 a 20cm - opera√ß√£o dentro do esperado.
- **ALERTA_Pre_falha (laranja)**: N√≠vel de 16 a 18cm - poss√≠vel acerela√ß√£o demasiada, aten√ß√£o recomendada.
- **FALHA_CRITICA (vermelho)**: N√≠vel abaixo de 16cm - ‚Äì indicativo de falha cr√≠tica, requer a√ß√£o imediata.

---

## ‚úÖ Insights Iniciais

- **NORMAL**
- **ALERTA_Pre_falha**
- **FALHA_CRITICA**

Essa an√°lise demonstra que o sistema de simula√ß√£o e classifica√ß√£o est√° funcionando conforme esperado, permitindo a identifica√ß√£o clara de mudan√ßas na vibra√ß√£o, temperatura e n√≠vel de enchimento. Isso √© essencial para o monitoramento preventivo e tomada de decis√£o.

Essa categoriza√ß√£o tem como objetivo simular o comportamento de um sistema embarcado que n√£o apenas coleta dados, mas tamb√©m realiza uma **an√°lise embarcada**, classificando os dados com base em faixas de opera√ß√£o seguras ou cr√≠ticas. Essa estrat√©gia permite que o dispositivo reaja localmente ou envie alertas para a nuvem em casos de falha iminente, antecipando paradas e aumentando a confiabilidade do processo industrial.

Os gr√°ficos apresentados anteriormente, tamb√©m fornecem uma vis√£o clara da transi√ß√£o entre os diferentes estados, evidenciando o momento em que o sistema passa de uma opera√ß√£o est√°vel para condi√ß√µes cr√≠ticas.

---

## üìä Banco de Dados

Para armazenar os dados de forma estruturada, foi projetado um banco de dados relacional simples e eficiente, implementado em SQLite. Esta abordagem garante a integridade e facilita as consultas complexas necess√°rias para a an√°lise de Machine Learning.

### Diagrama Entidade-Relacionamento (DER)
O diagrama abaixo ilustra a modelagem, com suas entidades, atributos e relacionamentos.

![Modelagem de dados](img/modelagem.JPG)

### Descri√ß√£o das Entidades e Relacionamentos

A modelagem de dados foi estruturada para refletir o ambiente industrial de forma clara e normalizada:

* **MAQUINAS:** Entidade central que representa os equipamentos f√≠sicos na linha de produ√ß√£o.
    * `id_maquina`: Chave prim√°ria para identifica√ß√£o √∫nica.
    * `nome`, `localizacao`: Atributos que descrevem a m√°quina.

* **SENSORES:** Representa os dispositivos de coleta de dados instalados nas m√°quinas.
    * `id_sensor`: Chave prim√°ria.
    * `id_maquina`: Chave estrangeira que estabelece o relacionamento **(1:N)** com a tabela `MAQUINAS`, indicando que **uma m√°quina pode ter v√°rios sensores**.
    * `tipologia`: Descreve o tipo de dado que o sensor coleta (temperatura, vibra√ß√£o, etc.).

* **MEDICAO_VIBRACAO / TEMPERATURA / NIVEL:** Tabelas que armazenam os dados hist√≥ricos de cada sensor.
    * `id`: Chave prim√°ria para cada registro de medi√ß√£o.
    * `id_sensor`: Chave estrangeira que estabelece o relacionamento **(1:N)** com a tabela `SENSORES`, indicando que **um sensor pode realizar m√∫ltiplas medi√ß√µes** ao longo do tempo.
    * `aceleracao_total`, `medicao`, `nivel_cm`: Atributos que guardam o valor num√©rico da leitura.
    * `status`: Campo que armazena a classifica√ß√£o da medi√ß√£o, fundamental para o treinamento do modelo de ML.

### Automa√ß√£o da Cria√ß√£o e Povoamento

Para garantir a consist√™ncia e reprodutibilidade do projeto, todo o processo de cria√ß√£o e povoamento do banco foi automatizado:

1.  **`schema.sql`:** Um √∫nico script cont√©m todo o c√≥digo DDL (Data Definition Language) para criar as tabelas e definir os relacionamentos (`FOREIGN KEY`), garantindo a integridade referencial.
2.  **`import_data.py`:** Este script Python utiliza a biblioteca `sqlite3` e `pandas` para:
    * Criar o banco `hermes_db.sqlite` executando o `schema.sql`.
    * Inserir os dados est√°ticos das m√°quinas e tipos de sensores.
    * Ler os arquivos `medicao_*.csv`, process√°-los e inseri-los nas tabelas de medi√ß√£o correspondentes.

```python
# Trecho do import_data.py que popula a tabela de vibra√ß√£o
df_vibracao = pd.read_csv('data/medicao_vibracao.csv')
df_vibracao['id_sensor'] = 3 # Associa ao sensor de vibra√ß√£o
df_vibracao = df_vibracao.rename(columns={'ID': 'id', 'Aceleracao_Total': 'aceleracao_total', 'Status': 'status'})
df_vibracao.to_sql('MEDICAO_VIBRACAO', conn, if_exists='append', index=False)
  
```

### Integra√ß√£o com Ferramentas de Visualiza√ß√£o

O banco de dados foi modelado de forma relacional e centralizada n√£o apenas para servir ao modelo de Machine Learning, mas tamb√©m para funcionar como uma fonte de dados robusta para ferramentas de Business Intelligence (BI). Em uma implementa√ß√£o industrial, os dados armazenados poderiam ser conectados a plataformas como **Power BI**, **Tableau** ou **Grafana** para a cria√ß√£o de dashboards interativos. Isso permitiria que os gestores da linha de produ√ß√£o monitorem a sa√∫de dos equipamentos em tempo real, analisem tend√™ncias hist√≥ricas e tomem decis√µes mais assertivas baseadas em dados visuais.

---

# üìú Etapas

## 1. Cadastro de m√°quinas
H√° necessidade de cadastrar todas as m√°quinas da ind√∫stria.

üìä **Dados Necess√°rios**
- Nome da m√°quina
- Localiza√ß√£o da m√°quina dentro da ind√∫stria

## 2. Identifica√ß√£o dos sensores
H√° necessidade de identifica√ß√£o de todos os sensores presentes nas m√°quinas.

üìä **Dados Necess√°rios**
- Tipologia
- M√°quina localizada

## 3. Recebimento de dados de sensores
O sistema dever√° receber os dados de cada sensor.

üìä **Dados Recebidos**
- Medi√ß√£o
- Status

## 4. Banco de dados
A partir das informa√ß√µes recebidas e registradas, dever√£o ser armazenadas em um banco de dados. 

> Os relacionamentos entre as entidades ir√£o proporcionar insights valiosos que poder√£o ser detectados pelo modelo preditivo.

---

# üñ•Ô∏è Machine Learning

O objetivo do modelo de Machine Learning √© classificar o status de opera√ß√£o com base nas leituras dos sensores. O processo foi documentado no notebook `machine_learning.ipynb`.

1.  **Carga e Unifica√ß√£o dos Dados**
    
    Os dados de todas as tabelas de medi√ß√£o foram unificados com uma consulta SQL diretamente no banco de dados, criando um √∫nico DataFrame para o treinamento.

    ```python
    # Unifica os dados de todos os sensores
    query = """
    SELECT 'nivel' as tipo, nivel_cm as medicao, status FROM MEDICAO_NIVEL
    UNION ALL
    SELECT 'temperatura' as tipo, medicao, status FROM MEDICAO_TEMPERATURA
    UNION ALL
    SELECT 'vibracao' as tipo, aceleracao_total as medicao, status FROM MEDICAO_VIBRACAO;
    """
    df = pd.read_sql_query(query, conn)
    ```

2.  **Treinamento do Modelo**
    
    Foi utilizado um modelo de √Årvore de Decis√£o (DecisionTreeClassifier), escolhido por sua simplicidade e interpretabilidade. Os dados foram divididos em 70% para treino e 30% para teste.

3.  **Resultados e Avalia√ß√£o**
    
    O modelo alcan√ßou uma acur√°cia de 100% no conjunto de teste. Este resultado perfeito √© esperado, pois os dados foram gerados com regras de classifica√ß√£o claras. Isso valida que o modelo aprendeu perfeitamente as regras definidas, servindo como uma excelente prova de conceito. Todavia, em um cen√°rio real, os dados teriam mais "ru√≠do" e as fronteiras entre as classes n√£o seriam t√£o perfeitas, o que levaria a uma acur√°cia menor, mas ainda assim o modelo seria √∫til.
    
    Para visualizar a performance, foi gerada uma Matriz de Confus√£o.

    ![Matriz de Confus√£o](img/matriz_confusao.png)

4.  **Justificativa da Visualiza√ß√£o**
    
    A Matriz de Confus√£o √© a ferramenta padr√£o para avaliar modelos de classifica√ß√£o. A diagonal principal mostra o n√∫mero de previs√µes corretas para cada classe. No nosso caso, todos os valores est√£o na diagonal principal, confirmando que o modelo classificou todas as 450 amostras de teste corretamente, sem nenhum erro. Isso √© muito mais informativo do que apenas a acur√°cia geral.


## üìÅ Estrutura do Reposit√≥rio

```bash
/enterprise-challenge-phase04
/
‚îú‚îÄ‚îÄ .sql/
‚îÇ   ‚îî‚îÄ‚îÄ schema.sql                  # Script DDL para cria√ß√£o da estrutura do banco
‚îÇ
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ medicao_nivel.csv           # Dados simulados do sensor de n√≠vel
‚îÇ   ‚îú‚îÄ‚îÄ medicao_temperatura.csv     # Dados simulados do sensor de temperatura
‚îÇ   ‚îî‚îÄ‚îÄ medicao_vibracao.csv        # Dados simulados do sensor de vibra√ß√£o
‚îÇ
‚îú‚îÄ‚îÄ .json/
‚îÇ   ‚îú‚îÄ‚îÄ diagram_DS18B20.json        # Diagrama de circuito para o Wokwi
‚îÇ   ‚îú‚îÄ‚îÄ diagram_HC-SR04.json        # "
‚îÇ   ‚îî‚îÄ‚îÄ diagram_MPU6050.json        # "
‚îÇ
‚îú‚îÄ‚îÄ notebooks/
‚îÇ   ‚îú‚îÄ‚îÄ grafico.ipynb               # (Opcional) Notebook para gera√ß√£o de gr√°ficos avulsos
‚îÇ   ‚îî‚îÄ‚îÄ machine_learning.ipynb      # Notebook principal com o treino e avalia√ß√£o do modelo
‚îÇ
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ update_diagram.py           # Script para atualizar o diagrama do Wokwi automaticamente
|   ‚îî‚îÄ‚îÄ import_data.py              # Script para popular banco de dados com dados de medi√ß√£o
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ ds18b20_main.cpp            # C√≥digo-fonte da simula√ß√£o para o sensor de temperatura
‚îÇ   ‚îú‚îÄ‚îÄ hcsr04_main.cpp             # C√≥digo-fonte da simula√ß√£o para o sensor de n√≠vel
‚îÇ   ‚îî‚îÄ‚îÄ mpu6050_main.cpp            # C√≥digo-fonte da simula√ß√£o para o sensor de vibra√ß√£o
‚îÇ
‚îú‚îÄ‚îÄ .gitignore                      # Arquivos ignorados pelo Git
‚îú‚îÄ‚îÄ diagram.json                    # Arquivo de diagrama ATUAL do Wokwi (gerado via script)
‚îú‚îÄ‚îÄ platformio.ini                  # Configura√ß√£o do PlatformIO com m√∫ltiplos ambientes
‚îú‚îÄ‚îÄ README.md                       # Esta documenta√ß√£o
‚îî‚îÄ‚îÄ wokwi.toml                      # Configura√ß√£o do Wokwi para carregar o firmware
```
---

## üß† Conclus√£o

Nesta fase do projeto, evolu√≠mos da simula√ß√£o de dados para a constru√ß√£o de uma solu√ß√£o de dados completa e integrada. A cria√ß√£o de um banco de dados relacional e a automa√ß√£o da importa√ß√£o de dados estabeleceram uma base s√≥lida e escal√°vel. A aplica√ß√£o de um modelo de Machine Learning demonstrou com sucesso a capacidade de extrair insights preditivos, validando o pipeline de ponta a ponta. O projeto agora n√£o apenas coleta e armazena dados, mas tamb√©m os utiliza para gerar intelig√™ncia, cumprindo plenamente os objetivos da manuten√ß√£o preditiva.

---

## üé¨ V√≠deo Explicativo

Assista ao v√≠deo de at√© 5 minutos explicando e justificando o projeto desta fase:

[Link para o v√≠deo no YouTube (N√£o Listado)]()

---

## üìú Licen√ßa

Este projeto est√° licenciado sob os termos da licen√ßa **CC BY 4.0**.

---
