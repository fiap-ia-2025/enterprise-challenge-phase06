# FIAP - Faculdade de Inform√°tica e Administra√ß√£o Paulista

<p align="center">
  <a href="https://www.fiap.com.br/">
    <img src="img/logo-fiap.png" alt="FIAP - Faculdade de Inform√°tica e Administra√ß√£o Paulista" border="0" width="40%" height="40%">
  </a>
</p>

---

# üì¶ Enterprise Challenge - Sprint 4


## üë• Grupo 18


## üë®‚Äçüéì Integrantes:
- Amanda Vieira Pires (RM5666330)
- Ana Gabriela Soares Santos (RM565235)
- Bianca Nascimento de Santa Cruz Oliveira (RM561390)
- Milena Pereira dos Santos Silva (RM565464)
- Nayana Mehta Miazaki (RM565045) 

## üë©‚Äçüè´ Professores:
### Tutor(a)  
-  Lucas Gomes Moreira
### Coordenador(a)  
- Andr√© Godoi

---

## üìú Descri√ß√£o do Projeto  

Solu√ß√£o de **manuten√ß√£o preditiva** em linhas de envase de bebidas.  
- **Sensores simulados (ESP32 + Wokwi):** temperatura (DS18B20), vibra√ß√£o (MPU6050) e n√≠vel (HC-SR04).  
- **Armazenamento:** SQLite.  
- **An√°lise preditiva:** modelo de Machine Learning (√Årvore de Decis√£o).  
- **Visualiza√ß√£o:** dashboard em Streamlit.  

---

## üîß Pipeline de Solu√ß√£o  

1. **Simula√ß√£o de Sensores** ‚Üí exporta dados em `.csv`.  
2. **Estrutura√ß√£o de Dados** ‚Üí importa√ß√£o para SQLite (`import_data.py`).  
3. **Machine Learning** ‚Üí treinamento e avalia√ß√£o (`machine_learning.ipynb`).  
4. **Dashboard** ‚Üí visualiza√ß√£o de m√©tricas e previs√µes.  

## üìÅ Arquitetura final

![Arquitetura Final](img/Arquitetura_final.png)

---

## üöÄ Como Executar  

### Pr√©-requisitos  
- Python 3.8+  
- VS Code com: PlatformIO, Wokwi, Jupyter, SQLite Viewer  


### Passo a Passo
O processo completo √© dividido em 4 fases principais: gerar os dados, estrutur√°-los no banco de dados, treinar o modelo de Machine Learning e apresentar os dados em Dashboard.

## üîπ Fase 1: Gera√ß√£o de Dados Simulados (Wokwi)

Existem duas maneiras de gerar os dados. Escolha a que melhor se adapta √† sua necessidade.

---

1. **Escolha o ambiente do sensor**  
   - Clique no √≠cone do PlatformIO (formiga) na barra lateral esquerda do VS Code.
   - Em PROJECT TASKS, expanda a lista e escolha o ambiente do sensor que deseja simular (ex: `sensor_nivel_hcsr04`).

2. **Compile o C√≥digo (Build):**  
   - Clique na op√ß√£o Build dentro do ambiente escolhido. 
   - Aguarde a mensagem de SUCCESS no terminal. Esse processo tamb√©m executa o script `update_diagram.py`, que atualiza o arquivo `diagram.json` com o circuito correto.

3. **Ajuste o `wokwi.toml`**  
   - Abra o arquivo `wokwi.toml` na raiz do projeto.
   - Altere a linha firmware para apontar para o arquivo `.elf` do sensor que voc√™ acabou de compilar. O caminho correto ser√° exibido no terminal ap√≥s o build.
     - Exemplo para o sensor de n√≠vel:
       
     ```toml
     firmware = ".pio/build/sensor_nivel_hcsr04/firmware.elf"
     ```

4. **Inicie a Simula√ß√£o**  
   - Pressione F1 para abrir a paleta de comandos do VS Code. 
   - Digite e selecione Wokwi: Start Simulator.
   - A simula√ß√£o iniciar√° em uma nova aba. Copie os dados gerados no Serial Monitor e salve-os no arquivo `.csv` correspondente dentro da pasta `data/`.

5. **Repita para os Outros Sensores**  
   - Para gerar os dados dos outros sensores, repita os passos de 1 a 4, selecionando o ambiente e atualizando o `wokwi.toml` para cada um.

---

## üîπ Fase 2: Estrutura√ß√£o dos Dados

  1. Instale as depend√™ncias Python:
  ```bash
    pip install pandas scikit-learn matplotlib seaborn plotly
  ```

  2. Execute o script de importa√ß√£o para criar e popular o banco de dados `hermes_db.sqlite` e popul√°-lo com os dados dos arquivos CSV:
  ```bash
    python scripts/import_data.py
  ```

## üîπ Fase 3: An√°lise com Machine Learning

  1. (Opcional) An√°lise Explorat√≥ria:
       - Abra o notebook `notebooks/grafico.ipynb`.
       - Execute as c√©lulas para gerar gr√°ficos individuais para cada tipo de sensor, permitindo uma visualiza√ß√£o inicial dos dados coletados.
         
  2. Clique em "Executar Tudo" (Run All). O notebook ir√° treinar o modelo e exibir a Matriz de Confus√£o com os resultados.
       - Abra o notebook principal `notebooks/machine_learning.ipynb`.
       - Clique em **"Executar Tudo" (Run All)**. O notebook ir√° carregar os dados do banco, treinar o modelo de classifica√ß√£o e exibir a Matriz de Confus√£o com os resultados finais.

## üîπ Fase 4: Dashboard

 1. V√° para a pasta /src/streamlit
 2. Execute o seguinte comando

  ```bash
    streamlit run app.py
  ```

3. Abra o seguinte endere√ßo no navegador: http://localhost:8501/


## üìå Justificativa da Escolha do Sensor

O sensor **DS18B20** foi escolhido para a leitura precisa de temperatura, o **MPU6050** para medir a vibra√ß√£o da m√°quina atrav√©s de seu aceler√¥metro, e o **HC-SR04** para a medi√ß√£o do n√≠vel de enchimento sem contato com o produto. Em conjunto, esses sensores permitem simular um cen√°rio realista de monitoramento em linhas de envase de bebidas, onde varia√ß√µes nessas tr√™s grandezas s√£o indicadores cr√≠ticos de poss√≠veis falhas no processo.

---

## üîå Esquema dos Circuitos

## üí® MPU6050

### ‚öôÔ∏è Funcionamento do Sistema MPU6050

1. O ESP32 simulado l√™ a acelera√ß√£o da m√°quina a cada 1 segundo atrav√©s do MPU6050.
2. A vibra√ß√£o √© simulada com valores variados, dependendo da movimenta√ß√£o dos eixos X, Y e Z.
3. Os dados s√£o classificados automaticamente em tr√™s status:
   - **NORMAL**: at√© 16500.0LSB/g
   - **ALERTA_Pre_falha**: de 16500.0LSB/g at√© 25000.0LSB/g
   - **FALHA_CRITICA**: acima de 25000.0LSB/g
4. Os dados s√£o exibidos no **Monitor Serial** no formato CSV:  
   `ID, Aceleracao_Total, Status`

---

### üîå Simula√ß√£o no Wokwi - MPU6050 e ESP32
![Simula√ß√£o MPU6050](img/mpu5060_terminal.JPG)


---

## üå°Ô∏è DS18B20

### ‚öôÔ∏è Funcionamento do Sistema DS18B20

1. O ESP32 simulado l√™ a temperatura da m√°quina a cada 1 segundo atrav√©s do DS18B20.
2. A temperatura √© simulada com valores variados, conforme a oscila√ß√£o.
3. Os dados s√£o classificados automaticamente em tr√™s status:
   - **NORMAL**: de -1¬∫C at√© 6¬∫C
   - **ALERTA_Pre_falha**: de 6.1¬∫C at√© 10¬∫C ou de -1.1¬∫C at√© -6¬∫C 
   - **FALHA_CRITICA**: acima de 10¬∫C ou abaixo de -6.1¬∫C
4. Os dados s√£o exibidos no **Monitor Serial** no formato CSV:  
   `ID, Temperatura, Status`

---

### üîå Simula√ß√£o no Wokwi - DS18B20 e ESP32
![Simula√ß√£o DS18B20](img/ds18b20_terminal.JPG)

---

## „Ä∞Ô∏è HC-SR04

### ‚öôÔ∏è Funcionamento do Sistema HC-SR04

1. O ESP32 simulado l√™ a dist√¢ncia do l√≠quido at√© o sensor HC-SR04 a cada 1 segundo.
2. A temperatura √© simulada com valores variados, conforme a oscila√ß√£o.
3. Os dados s√£o classificados automaticamente em tr√™s status:
   - **NORMAL**: acima de 20cm
   - **ALERTA_Pre_falha**: de 16 a 18cm
   - **FALHA_CRITICA**: abaixo de 16cm
4. Os dados s√£o exibidos no **Monitor Serial** no formato CSV:  
   `ID, Distancia_cm, Nivel_cm, Status`

---

### üîå Simula√ß√£o no Wokwi - HC-SR04 e ESP32
![Simula√ß√£o HC-SR04](img/HC-SR04_terminal.JPG)

---

## ‚úÖ Insights Iniciais

- **NORMAL**
- **ALERTA_Pre_falha**
- **FALHA_CRITICA**

Essa an√°lise demonstra que o sistema de simula√ß√£o e classifica√ß√£o est√° funcionando conforme esperado, permitindo a identifica√ß√£o clara de mudan√ßas na vibra√ß√£o, temperatura e n√≠vel de enchimento. Isso √© essencial para o monitoramento preventivo e tomada de decis√£o.

Essa categoriza√ß√£o tem como objetivo simular o comportamento de um sistema embarcado que n√£o apenas coleta dados, mas tamb√©m realiza uma **an√°lise embarcada**, classificando os dados com base em faixas de opera√ß√£o seguras ou cr√≠ticas. Essa estrat√©gia permite que o dispositivo reaja localmente ou envie alertas para a nuvem em casos de falha iminente, antecipando paradas e aumentando a confiabilidade do processo industrial.

Os gr√°ficos apresentados anteriormente, tamb√©m fornecem uma vis√£o clara da transi√ß√£o entre os diferentes estados, evidenciando o momento em que o sistema passa de uma opera√ß√£o est√°vel para condi√ß√µes cr√≠ticas.

---

## üìä Banco de Dados

Para armazenar os dados de forma estruturada, foi projetado um banco de dados relacional simples e eficiente, implementado em SQLite. Esta abordagem garante a integridade e facilita as consultas complexas necess√°rias para a an√°lise de Machine Learning.

### Diagrama Entidade-Relacionamento (DER)
O diagrama abaixo ilustra a modelagem, com suas entidades, atributos e relacionamentos.

![Modelagem de dados](img/modelagem.JPG)

### Descri√ß√£o das Entidades e Relacionamentos

A modelagem de dados foi estruturada para refletir o ambiente industrial de forma clara e normalizada:

* **MAQUINAS:** Entidade central que representa os equipamentos f√≠sicos na linha de produ√ß√£o.
    * `id_maquina`: Chave prim√°ria para identifica√ß√£o √∫nica.
    * `nome`, `localizacao`: Atributos que descrevem a m√°quina.

* **SENSORES:** Representa os dispositivos de coleta de dados instalados nas m√°quinas.
    * `id_sensor`: Chave prim√°ria.
    * `id_maquina`: Chave estrangeira que estabelece o relacionamento **(1:N)** com a tabela `MAQUINAS`, indicando que **uma m√°quina pode ter v√°rios sensores**.
    * `tipologia`: Descreve o tipo de dado que o sensor coleta (temperatura, vibra√ß√£o, etc.).

* **MEDICAO_VIBRACAO / TEMPERATURA / NIVEL:** Tabelas que armazenam os dados hist√≥ricos de cada sensor.
    * `id`: Chave prim√°ria para cada registro de medi√ß√£o.
    * `id_sensor`: Chave estrangeira que estabelece o relacionamento **(1:N)** com a tabela `SENSORES`, indicando que **um sensor pode realizar m√∫ltiplas medi√ß√µes** ao longo do tempo.
    * `aceleracao_total`, `medicao`, `nivel_cm`: Atributos que guardam o valor num√©rico da leitura.
    * `status`: Campo que armazena a classifica√ß√£o da medi√ß√£o, fundamental para o treinamento do modelo de ML.

### Automa√ß√£o da Cria√ß√£o e Povoamento

Para garantir a consist√™ncia e reprodutibilidade do projeto, todo o processo de cria√ß√£o e povoamento do banco foi automatizado:

1.  **`schema.sql`:** Um √∫nico script cont√©m todo o c√≥digo DDL (Data Definition Language) para criar as tabelas e definir os relacionamentos (`FOREIGN KEY`), garantindo a integridade referencial.
2.  **`import_data.py`:** Este script Python utiliza a biblioteca `sqlite3` e `pandas` para:
    * Criar o banco `hermes_db.sqlite` executando o `schema.sql`.
    * Inserir os dados est√°ticos das m√°quinas e tipos de sensores.
    * Ler os arquivos `medicao_*.csv`, process√°-los e inseri-los nas tabelas de medi√ß√£o correspondentes.

### Dashboard

O Dashboard foi criado com o streamlit com o objetivo de apresentar m√©tricas, gr√°ficos e tornar o modelo de Machine Learning utiliz√°vel. Seguem abaixo imagens da interface:

![Imagem 1 Dashboard](img/dash_1.png)

![Imagem 2 Dashboard](img/dash_2.png)

![Imagem 3 Dashboard](img/dash_3.png)

![Imagem 4 Dashboard](img/dash_4_ML.png)

---

# üìú Etapas

## 1. Cadastro de m√°quinas
H√° necessidade de cadastrar todas as m√°quinas da ind√∫stria.

üìä **Dados Necess√°rios**
- Nome da m√°quina
- Localiza√ß√£o da m√°quina dentro da ind√∫stria

## 2. Identifica√ß√£o dos sensores
H√° necessidade de identifica√ß√£o de todos os sensores presentes nas m√°quinas.

üìä **Dados Necess√°rios**
- Tipologia
- M√°quina localizada

## 3. Recebimento de dados de sensores
O sistema dever√° receber os dados de cada sensor.

üìä **Dados Recebidos**
- Medi√ß√£o
- Status

## 4. Banco de dados
A partir das informa√ß√µes recebidas e registradas, dever√£o ser armazenadas em um banco de dados. 

> Os relacionamentos entre as entidades ir√£o proporcionar insights valiosos que poder√£o ser detectados pelo modelo preditivo.

---

## üñ•Ô∏è Machine Learning

O objetivo do modelo de Machine Learning √© classificar o status de opera√ß√£o com base nas leituras dos sensores. O processo foi documentado no notebook `machine_learning.ipynb`.

1.  **Carga e Unifica√ß√£o dos Dados**
    
    Os dados de todas as tabelas de medi√ß√£o foram unificados com uma consulta SQL diretamente no banco de dados, criando um √∫nico DataFrame para o treinamento.

    ```python
    # Unifica os dados de todos os sensores
    query = """
    SELECT 'nivel' as tipo, nivel_cm as medicao, status FROM MEDICAO_NIVEL
    UNION ALL
    SELECT 'temperatura' as tipo, medicao, status FROM MEDICAO_TEMPERATURA
    UNION ALL
    SELECT 'vibracao' as tipo, aceleracao_total as medicao, status FROM MEDICAO_VIBRACAO;
    """
    df = pd.read_sql_query(query, conn)
    ```

2.  **Treinamento do Modelo**
    
    Foi utilizado um modelo de √Årvore de Decis√£o (DecisionTreeClassifier), escolhido por sua simplicidade e interpretabilidade. Os dados foram divididos em 70% para treino e 30% para teste.

3.  **Resultados e Avalia√ß√£o**
    
    O modelo alcan√ßou uma acur√°cia de 100% no conjunto de teste. Este resultado perfeito √© esperado, pois os dados foram gerados com regras de classifica√ß√£o claras. Isso valida que o modelo aprendeu perfeitamente as regras definidas, servindo como uma excelente prova de conceito. Todavia, em um cen√°rio real, os dados teriam mais "ru√≠do" e as fronteiras entre as classes n√£o seriam t√£o perfeitas, o que levaria a uma acur√°cia menor, mas ainda assim o modelo seria √∫til.
    
    Para visualizar a performance, foi gerada uma Matriz de Confus√£o.

    ![Matriz de Confus√£o](img/matriz_confusao.png)

4.  **Justificativa da Visualiza√ß√£o**
    
    A Matriz de Confus√£o √© a ferramenta padr√£o para avaliar modelos de classifica√ß√£o. A diagonal principal mostra o n√∫mero de previs√µes corretas para cada classe. No nosso caso, todos os valores est√£o na diagonal principal, confirmando que o modelo classificou todas as 450 amostras de teste corretamente, sem nenhum erro. Isso √© muito mais informativo do que apenas a acur√°cia geral.


## üìÅ Estrutura do Reposit√≥rio

```bash
/enterprise-challenge-phase04
/
‚îú‚îÄ‚îÄ .sql/
‚îÇ   ‚îî‚îÄ‚îÄ schema.sql                  # Script DDL para cria√ß√£o da estrutura do banco
‚îÇ
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ medicao_nivel.csv           # Dados simulados do sensor de n√≠vel
‚îÇ   ‚îú‚îÄ‚îÄ medicao_temperatura.csv     # Dados simulados do sensor de temperatura
‚îÇ   ‚îî‚îÄ‚îÄ medicao_vibracao.csv        # Dados simulados do sensor de vibra√ß√£o
‚îÇ
‚îú‚îÄ‚îÄ .json/
‚îÇ   ‚îú‚îÄ‚îÄ diagram_DS18B20.json        # Diagrama de circuito para o Wokwi
‚îÇ   ‚îú‚îÄ‚îÄ diagram_HC-SR04.json        # "
‚îÇ   ‚îî‚îÄ‚îÄ diagram_MPU6050.json        # "
‚îÇ
‚îú‚îÄ‚îÄ notebooks/
‚îÇ   ‚îú‚îÄ‚îÄ grafico.ipynb               # (Opcional) Notebook para gera√ß√£o de gr√°ficos avulsos
‚îÇ   ‚îî‚îÄ‚îÄ machine_learning.ipynb      # Notebook principal com o treino e avalia√ß√£o do modelo
‚îÇ   ‚îî‚îÄ‚îÄ decision_tree_model.pkl     # Modelo treinado exportado
‚îÇ  
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ update_diagram.py           # Script para atualizar o diagrama do Wokwi automaticamente
|   ‚îî‚îÄ‚îÄ import_data.py              # Script para popular banco de dados com dados de medi√ß√£o
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ ds18b20_main.cpp            # C√≥digo-fonte da simula√ß√£o para o sensor de temperatura
‚îÇ   ‚îú‚îÄ‚îÄ hcsr04_main.cpp             # C√≥digo-fonte da simula√ß√£o para o sensor de n√≠vel
‚îÇ   ‚îî‚îÄ‚îÄ mpu6050_main.cpp            # C√≥digo-fonte da simula√ß√£o para o sensor de vibra√ß√£o
‚îÇ
‚îú‚îÄ‚îÄ .gitignore                      # Arquivos ignorados pelo Git
‚îú‚îÄ‚îÄ diagram.json                    # Arquivo de diagrama ATUAL do Wokwi (gerado via script)
‚îú‚îÄ‚îÄ platformio.ini                  # Configura√ß√£o do PlatformIO com m√∫ltiplos ambientes
‚îú‚îÄ‚îÄ README.md                       # Esta documenta√ß√£o
‚îî‚îÄ‚îÄ wokwi.toml                      # Configura√ß√£o do Wokwi para carregar o firmware
```
---

## üß† Conclus√£o

O produto final atende aos requisitos de coletar, armazenar, treinar e exibir os dados e m√©tricas. O funcionamento dele √© local, n√£o foi disponibilizado em ambiente produtivo. Como ponto a melhorar, caso d√™ continuidade, √© a disponibiliza√ß√£o em ambiente AWS.

---

## üé¨ V√≠deo Explicativo

Assista ao v√≠deo de at√© 5 minutos explicando e justificando o projeto desta fase:

[Link para o v√≠deo no YouTube (N√£o Listado)](https://www.youtube.com/watch?v=MVAWUlgGIO0)

---

## üìú Licen√ßa

Este projeto est√° licenciado sob os termos da licen√ßa **CC BY 4.0**.

---
